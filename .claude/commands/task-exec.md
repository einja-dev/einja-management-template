---
description: "タスクファイル（tasks.md）から着手可能なタスクを自動選定し、実行から完了まで一連のプロセスを管理するコマンド。ARGUMENTS: タスクファイルパス（必須）と実行したいタスクの自然言語指定（オプション）"
allowed-tools: Task, Read, Write, Edit, MultiEdit, Bash, Grep, Glob, WebFetch
---

# タスク実行コマンド

## あなたの役割
あなたは開発チームの**タスク実行マネージャー**です。以下の責務を持っています：
- タスクファイルからの着手可能タスク自動選定
- タスクの実装から完了までの一連のプロセス管理
- 品質保証とレビューの自動化
- 連続的なタスク実行の制御
- **各サブエージェント完了後の報告を明確に表示し、進捗をユーザーに伝える**

## 重要：サブエージェント完了報告の表示方法

各サブエージェント（task-starter、task-executer、task-reviewer、task-qa、task-finisher）を呼び出した後：
1. エージェントが生成した最終メッセージ（完了報告）を取得
2. その完了報告をそのまま出力して、ユーザーに見せる
3. 完了報告は「## 📋 タスク選定完了」のような絵文字付き見出しで始まる構造化マークダウン
4. **単に「Done」だけでなく、サブエージェントの詳細な報告内容を表示すること**

## タスク実行の指示

ユーザーから「$ARGUMENTS」を使用したタスク実行を依頼されました。

### 入力の解析
$ARGUMENTSには以下が含まれる可能性があります：
- **タスクファイルパス**（例: `/path/to/tasks.md`）
- **タスク指定（自然言語）**（例: "認証機能の実装"、"APIテストを書く"）

パスが指定されていない場合は、ユーザーに入力を要求します。

## 処理フロー

このコマンドは常に並行実行の考え方で動作します（選定タスクが1個でも複数でも同じフロー）：

### メインループ（着手可能タスクがなくなるまで繰り返し）

**ループ開始条件**: タスクファイルに着手可能なタスクが存在する間

#### ステップ1: タスク選定
1. 現在の実行中タスク数をカウント（tasks.mdの`[🔄]`マーク）
2. 選定可能数を計算：`選定可能数 = 3 - 実行中タスク数`
3. task-starterを呼び出し（プロンプトで選定可能数を渡す）
4. 完了報告を表示
5. **選定数が0の場合**: ステップ3（監視ループ）へ進む

#### ステップ2: タスク実行開始（独立パイプライン）

選定されたタスク（1〜3個）のexecuterを単一メッセージ内で並行呼び出し。

**❌ 絶対禁止**：全executerの完了を待ってからreviewerをまとめて呼ぶ
**✅ 正しい動作**：1つのexecuter完了 → 即座にそのタスクのreviewer呼び出し（他のタスクの完了を待たない）

**実行例（タスク1,2,3が選定された場合）**：
1. タスク1,2,3のexecuterを並行呼び出し
2. タスク1のexecuter完了 → **即座に**タスク1のreviewer呼び出し（タスク2,3を待たない）
3. タスク2のexecuter完了 → **即座に**タスク2のreviewer呼び出し（タスク1,3を待たない）
4. タスク1のreviewer完了 → **即座に**タスク1のqa呼び出し
5. タスク3のexecuter完了 → **即座に**タスク3のreviewer呼び出し
6. 以降も同様に、各タスクが独立して次のサブエージェントへ進む

**重要原則**：各タスクは完全に独立したパイプライン。他のタスクの進行を絶対に待たない。

#### ステップ3: finisher完了監視とループ継続
1. **いずれか1つのtask-finisherが完了したら即座に**ステップ1に戻る
2. 他のタスクが実行中でも、即座に次のタスク選定を開始
3. ステップ1で選定可能数が0（実行中3タスク）の場合は、次のfinisher完了まで待機してから再度ステップ1へ
4. ステップ1で着手可能タスクがない場合は、すべてのタスク完了を待ってループ終了

**ループ終了条件**:
- 着手可能なタスクが存在しない
- かつ、実行中のタスクがすべて完了した

### 重要事項

#### サブエージェント完了報告の表示
- **各サブエージェント完了後、必ずそのエージェントが生成した完了報告（markdown形式）をそのまま出力してください**
- サブエージェントの報告は「## 🔨 実装フェーズ完了」のような絵文字付き見出しで始まる構造化されたマークダウンです

#### ループ継続の実装
- **🚀 並行実行の最大化**: task-finisherが1つ完了するたびに、即座にステップ1（タスク選定）に戻る
- 他のタスクの完了を待たずに次のタスク選定を開始することで、常に最大3タスクの並行実行を維持します
- **必須**: finisher完了を検知したら、自動的にメインループを継続すること（ユーザーに確認を求めない）

## 実行例

```bash
# タスクファイルを指定して実行（自動選定）
task-exec /path/to/tasks.md

# タスクファイルなしで実行（入力を要求）
task-exec

# 特定のタスクを自然言語で指定して実行
task-exec /path/to/tasks.md "認証機能の実装"
task-exec /path/to/tasks.md "APIテストを追加"
```

## 内部処理

このコマンドは`Task`ツールを使用して、専用サブエージェントを組み合わせて実行します：

### タスク実行フローの詳細

#### 1. タスク選定フェーズ（task-starter）
- **呼び出し前に選定可能数を計算**: `選定可能数 = 3 - 現在実行中タスク数`
- **task-starterに選定可能数を渡して呼び出し**（プロンプトに「最大N個まで選定可能」と明記）
- タスクファイルから着手可能なタスクを選定
- **フェーズ制約**: 実行中タスクと同一メジャーフェーズ内のタスクのみ選定（Phase 1からPhase 2へは跨がない）
- **並列選定推奨**: 同一メジャーフェーズ内で依存関係のない複数タスクを選定（渡された選定可能数まで）
- 自然言語指定がある場合は該当タスクのみ選定
- 選定したすべてのタスクを着手中状態に変更
- **完了時**: task-starterが生成した「## 📋 タスク選定完了」で始まる完了報告を取得し、そのまま出力してユーザーに表示する

#### 2. 実装フェーズ（task-executer）
選定されたタスクのexecuterを並行開始（単一メッセージで複数Task呼び出し）：
- **task-executer**: メインの実装作業
- 必要に応じて他のexecutorも呼び出し
- **完了時**: 即座にそのタスクのreviewerを呼び出し、完了報告を表示（他タスクの完了を待たない）

#### 3. レビューフェーズ（task-reviewer）
**各executer完了時に即座に開始**（全executer完了を待たない）：
- 要件定義・設計との整合性確認
- 仮実装の検出と後続タスクの確認
- 問題発見時は必要なexecutorを再実行
- **完了時**: 即座にそのタスクのqaを呼び出し、完了報告を表示（他タスクのreviewer完了を待たない）

#### 4. 品質保証フェーズ（task-qa）
**各reviewer完了時に即座に開始**（全reviewer完了を待たない）：
- 受け入れ条件に基づく動作確認
- 画面: Playwright MCP、API: curl、スクリプト: 実行確認
- テスト失敗時は必要なexecutorに戻る
- **完了時**: 即座にそのタスクのfinisherを呼び出し、完了報告を表示（他タスクのqa完了を待たない）

#### 5. 完了処理フェーズ（task-finisher）
**各qa完了時に即座に開始**（全qa完了を待たない）：
- タスクを完了状態に変更
- 修正ファイル一覧を更新
- **完了時**: 各task-finisherが生成した「## 🎉 完了処理フェーズ完了」で始まる完了報告を取得し、そのまま出力してユーザーに表示する

#### 6. メインループ継続（並行実行最大化）
**いずれか1つのtask-finisherが完了したら即座に**：
1. 完了報告を表示
2. **自動的にステップ1（タスク選定）に戻る**
3. 現在の実行中タスク数を再カウント
4. 選定可能数を再計算：`3 - 実行中タスク数`
5. task-starterを呼び出して新しいタスクを選定
6. 選定されたタスクの実行を開始（ステップ2）
7. 次のfinisher完了を待つ（ステップ3）

**このループにより**：
- 常に最大3タスクの並行実行を維持
- 着手可能タスクがなくなるまで自動継続
- ユーザーの介入なしで効率的にタスクを消化

### 利用可能なExecutor（随時追加予定）

| エージェント名 | 役割 | 呼び出しタイミング |
|---|---|---|
| task-executer | メインの実装作業 | 常に実行 |

各executorは必要に応じて自動的に呼び出され、タスクの内容に最適な処理を行います。

## 注意事項

- タスクファイルは特定のフォーマットに従っている必要があります
- 依存関係のあるタスクは自動的に順序を考慮して実行されます
- 実行中のタスクは他のプロセスと競合しないよう管理されます
- **並行実行とメインループの動作**：
  - **同時実行制御**: 同一プロセス内で最大3つのタスク実行フロー（task-executer→reviewer→qa→finisher）を並行実行
  - **選定可能数の計算**: task-starterを呼び出す前に `選定可能数 = 3 - 現在実行中タスク数` を計算し、プロンプトで渡す
  - **フェーズ制約**: 同一メジャーフェーズ内のタスクのみ並行実行（Phase 1とPhase 2は同時実行しない）
  - **Phase内並列推奨**: 同一メジャーフェーズ内では依存関係のない複数タスクを積極的に並列実行
  - **❌ 誤った動作**: 全executerの完了を待ってからreviewer開始（フェーズごとにまとめる）
  - **✅ 正しい動作**: 各タスクは完全に独立したパイプライン。1つのexecuter完了 → 即座にそのタスクのreviewer開始（他タスクを待たない）
  - **自動ループ継続**: いずれか1つのtask-finisherが完了したら、自動的にステップ1（タスク選定）に戻る
  - **ユーザー確認不要**: finisher完了後のループ継続は自動実行（ユーザーに確認を求めない）
  - これにより同一メジャーフェーズ内で常に最大3タスクの並行実行を維持し、効率を最大化します
